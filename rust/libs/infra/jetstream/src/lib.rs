// infra/jetstream/src/lib.rs
//! JetStream infrastructure helper crate
//!
//! * collects all `event_metadata::StreamDef` that were generated by `#[event]` macros
//! * applies the definitions to a real JetStream instance at runtime
//! * exposes a thin `connect()` helper that returns a configured `async_nats::jetstream::JetStream`

use anyhow::{Context, Result};
use async_nats::{self, jetstream, ConnectOptions};
use std::time::Duration;

mod js_publisher;
mod js_subscriber;

pub use js_publisher::JsPublisher;
pub use js_subscriber::JsSubscriber;

/// Wrapper that holds a connected JetStream context plus the underlying client (kept for drop order).
#[derive(Clone)]
pub struct JetStreamCtx {
    /// Async‑NATS connection (kept so it lives as long as JetStream)
    _client: async_nats::Client,
    /// JetStream context used by the app
    pub js: jetstream::context::Context,
}

/// Connects to NATS & JetStream with sensible defaults (retry, TLS etc. optional).
pub async fn connect(nats_url: &str) -> Result<JetStreamCtx> {
    let client = async_nats::connect_with_options(nats_url, ConnectOptions::default())
        .await
        .context("failed to connect to NATS")?;

    let js = jetstream::new(client.clone());
    Ok(JetStreamCtx {
        _client: client,
        js,
    })
}

/// 登録されたすべてのストリームを接続されたJetStreamインスタンスに適用します。
///
/// *既存のストリーム*は更新されます（冪等）— 起動時に毎回実行できます。
pub async fn setup_all_streams(js: &jetstream::context::Context) -> Result<()> {
    use shared_core::streams::get_all_stream_configs;

    // 登録されたすべてのストリーム設定を取得
    for config in get_all_stream_configs() {
        // JetStream設定に変換
        let js_config = jetstream::stream::Config {
            name: config.name.clone(),
            subjects: vec![format!("{}.*", config.name)], // ワイルドカードサブジェクト
            max_age: config.max_age.unwrap_or(Duration::from_secs(0)),
            // max_deliver と ack_wait は consumer 設定に移動
            ..Default::default()
        };

        // idempotent: create if absent, update if present
        match js.get_or_create_stream(&js_config).await {
            Ok(_) => {
                js.update_stream(js_config).await?;
            }
            Err(e) => return Err(e.into()),
        }
    }

    Ok(())
}
