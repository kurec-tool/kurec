// infra/jetstream/src/lib.rs
//! JetStream infrastructure helper crate
//!
//! * collects all `event_metadata::StreamDef` that were generated by `#[event]` macros
//! * applies the definitions to a real JetStream instance at runtime
//! * exposes a thin `connect()` helper that returns a configured `async_nats::jetstream::JetStream`

use anyhow::{Context, Result};
use async_nats::{self, jetstream, ConnectOptions};
use std::time::Duration;

mod js_publisher;
mod js_subscriber;

pub use js_publisher::JsPublisher;
pub use js_subscriber::JsSubscriber;

/// Wrapper that holds a connected JetStream context plus the underlying client (kept for drop order).
#[derive(Clone)]
pub struct JetStreamCtx {
    /// Async‑NATS connection (kept so it lives as long as JetStream)
    _client: async_nats::Client,
    /// JetStream context used by the app
    pub js: jetstream::context::Context,
}

/// Connects to NATS & JetStream with sensible defaults (retry, TLS etc. optional).
pub async fn connect(nats_url: &str) -> Result<JetStreamCtx> {
    let client = async_nats::connect_with_options(nats_url, ConnectOptions::default())
        .await
        .context("failed to connect to NATS")?;

    let js = jetstream::new(client.clone());
    Ok(JetStreamCtx {
        _client: client,
        js,
    })
}

/// Apply **all** `#[event]`‑generated streams to the connected JetStream instance.
///
/// *Existing streams* are updated (idempotent) — so you can run this on every boot.
pub async fn setup_all_streams(js: &jetstream::context::Context) -> Result<()> {
    let defs: Vec<_> = inventory::iter::<shared_core::event_metadata::StreamDef>
        .into_iter()
        .collect();

    for def in defs {
        // Convert default config & create/update stream
        let cfg = jetstream::stream::Config {
            name: def.name.to_string(),
            subjects: def.subjects.iter().map(|s| s.to_string()).collect(),
            max_age: def.default_config.max_age.unwrap_or(Duration::from_secs(0)),
            ..Default::default()
        };

        // idempotent: create if absent, update if present
        match js.get_or_create_stream(&cfg).await {
            Ok(_) => {
                js.update_stream(cfg).await?;
            }
            Err(e) => return Err(e.into()),
        }
    }
    Ok(())
}
