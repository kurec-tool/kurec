/*
 * mirakc Web API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0.0-dev.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`check_channel_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckChannelStreamError {
    Status404(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`check_program_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckProgramStreamError {
    Status404(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`check_record_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckRecordStreamError {
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`check_service_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckServiceStreamError {
    Status404(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_channel_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChannelStreamError {
    Status404(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_program_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProgramStreamError {
    Status404(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_record_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordStreamError {
    Status400(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_service_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetServiceStreamError {
    Status404(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_service_stream_by_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetServiceStreamByChannelError {
    Status404(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeadError {
    Status404(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

pub async fn check_channel_stream(
    configuration: &configuration::Configuration,
    r#type: models::ChannelType,
    channel: &str,
    x_mirakurun_priority: Option<i32>,
    decode: Option<bool>,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<CheckChannelStreamError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_channel = channel;
    let p_x_mirakurun_priority = x_mirakurun_priority;
    let p_decode = decode;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!("{}/channels/{type}/{channel}/stream", configuration.base_path, type=p_type.to_string(), channel=crate::apis::urlencode(p_channel));
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref param_value) = p_decode {
        req_builder = req_builder.query(&[("decode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_mirakurun_priority {
        req_builder = req_builder.header("X-Mirakurun-Priority", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckChannelStreamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn check_program_stream(
    configuration: &configuration::Configuration,
    id: i64,
    x_mirakurun_priority: Option<i32>,
    decode: Option<bool>,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<CheckProgramStreamError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_mirakurun_priority = x_mirakurun_priority;
    let p_decode = decode;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!(
        "{}/programs/{id}/stream",
        configuration.base_path,
        id = p_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref param_value) = p_decode {
        req_builder = req_builder.query(&[("decode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_mirakurun_priority {
        req_builder = req_builder.header("X-Mirakurun-Priority", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckProgramStreamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn check_record_stream(
    configuration: &configuration::Configuration,
    id: &str,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<CheckRecordStreamError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!(
        "{}/recording/records/{id}/stream",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckRecordStreamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn check_service_stream(
    configuration: &configuration::Configuration,
    id: i64,
    x_mirakurun_priority: Option<i32>,
    decode: Option<bool>,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<CheckServiceStreamError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_mirakurun_priority = x_mirakurun_priority;
    let p_decode = decode;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!(
        "{}/services/{id}/stream",
        configuration.base_path,
        id = p_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref param_value) = p_decode {
        req_builder = req_builder.query(&[("decode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_mirakurun_priority {
        req_builder = req_builder.header("X-Mirakurun-Priority", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckServiceStreamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_channel_stream(
    configuration: &configuration::Configuration,
    r#type: models::ChannelType,
    channel: &str,
    x_mirakurun_priority: Option<i32>,
    decode: Option<bool>,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<GetChannelStreamError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_channel = channel;
    let p_x_mirakurun_priority = x_mirakurun_priority;
    let p_decode = decode;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!("{}/channels/{type}/{channel}/stream", configuration.base_path, type=p_type.to_string(), channel=crate::apis::urlencode(p_channel));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_decode {
        req_builder = req_builder.query(&[("decode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_mirakurun_priority {
        req_builder = req_builder.header("X-Mirakurun-Priority", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetChannelStreamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ### A special hack for EPGStation  If the User-Agent header string starts with \"EPGStation/\", this endpoint creates a temporal on-air program tracker if there is no tracker defined in config.yml, which can be reused for tracking changes of the TV program metadata.  The temporal on-air program tracker will be stopped within 1 minute after the streaming stopped.  The metadata will be returned from [/programs/{id}](#/programs/getProgram).
pub async fn get_program_stream(
    configuration: &configuration::Configuration,
    id: i64,
    x_mirakurun_priority: Option<i32>,
    decode: Option<bool>,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<GetProgramStreamError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_mirakurun_priority = x_mirakurun_priority;
    let p_decode = decode;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!(
        "{}/programs/{id}/stream",
        configuration.base_path,
        id = p_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_decode {
        req_builder = req_builder.query(&[("decode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_mirakurun_priority {
        req_builder = req_builder.header("X-Mirakurun-Priority", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProgramStreamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// It's possible to get a media stream of the record even while it's recording.  In this case, data will be sent when data is appended to the content file event if the stream reaches EOF at that point.  The streaming will stop within 2 seconds after the stream reaches the *true* EOF.  A request for a record without content file always returns status code 204.  A range request with filters always causes an error response with status code 400.
pub async fn get_record_stream(
    configuration: &configuration::Configuration,
    id: &str,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<GetRecordStreamError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!(
        "{}/recording/records/{id}/stream",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRecordStreamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_service_stream(
    configuration: &configuration::Configuration,
    id: i64,
    x_mirakurun_priority: Option<i32>,
    decode: Option<bool>,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<GetServiceStreamError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_mirakurun_priority = x_mirakurun_priority;
    let p_decode = decode;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!(
        "{}/services/{id}/stream",
        configuration.base_path,
        id = p_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_decode {
        req_builder = req_builder.query(&[("decode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_mirakurun_priority {
        req_builder = req_builder.header("X-Mirakurun-Priority", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetServiceStreamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_service_stream_by_channel(
    configuration: &configuration::Configuration,
    r#type: models::ChannelType,
    channel: &str,
    sid: i32,
    x_mirakurun_priority: Option<i32>,
    decode: Option<bool>,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<GetServiceStreamByChannelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_channel = channel;
    let p_sid = sid;
    let p_x_mirakurun_priority = x_mirakurun_priority;
    let p_decode = decode;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!("{}/channels/{type}/{channel}/services/{sid}/stream", configuration.base_path, type=p_type.to_string(), channel=crate::apis::urlencode(p_channel), sid=p_sid);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_decode {
        req_builder = req_builder.query(&[("decode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_mirakurun_priority {
        req_builder = req_builder.header("X-Mirakurun-Priority", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetServiceStreamByChannelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn head(
    configuration: &configuration::Configuration,
    r#type: models::ChannelType,
    channel: &str,
    sid: i32,
    x_mirakurun_priority: Option<i32>,
    decode: Option<bool>,
    pre_filters: Option<Vec<String>>,
    post_filters: Option<Vec<String>>,
) -> Result<(), Error<HeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_channel = channel;
    let p_sid = sid;
    let p_x_mirakurun_priority = x_mirakurun_priority;
    let p_decode = decode;
    let p_pre_filters = pre_filters;
    let p_post_filters = post_filters;

    let uri_str = format!("{}/channels/{type}/{channel}/services/{sid}/stream", configuration.base_path, type=p_type.to_string(), channel=crate::apis::urlencode(p_channel), sid=p_sid);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref param_value) = p_decode {
        req_builder = req_builder.query(&[("decode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pre_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("pre-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "pre-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_post_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("post-filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "post-filters",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_mirakurun_priority {
        req_builder = req_builder.header("X-Mirakurun-Priority", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<HeadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
